## R Lecture basics

**R은 함수 지향형 언어이다.**

### 데이터 구조

#### 1. 스칼라
```R
x <- 1
a <- "X"
a <- "variable"
```

#### 2. 벡터
```R
a <- c(1,2,3,4,5,6,7,8)
a[2:4] # 2 3 4
```

#### 3. 행렬
```R
matrix(벡터, ncol=열사이즈, nrow=행사이즈, byrow=F)
m <- matrix(x(1,2,3,4,5,6),ncol=3)
dim(m) # 행렬의 차수
```

#### 4. 다양한 벡터, 행렬의 요소참조 방법
```R
a <- c(1,2,3,4,5,6,7,8,9,10)
m <- matrix(c(1,2,3,4,5,6), ncol=3, byrow=T)

m[3:6] # 3 4 5 6
m[1,2:3] # 2 3

# 임의의 요소에 대한 참조
a[c(1,4,7)] # 1 4 7

# 임의의 요소를 제외하려면
a[-c(1,4,7)] # 2 3 5 6 8 9 10

# 행렬에서 특정 행 or 열을 참조하기 위하여
m[1,] # 1 2 3
```

#### 5. 수열
```R
# 시작 값:종료 값
b <- 4:9 # 4 5 6 7 8 9

# 수열 생성
seq(from=시작값, to=종료값, by=공차)
x <- seq(2,4,by=0.1) # 2.0 2.1 ... 3.9 4.0

# 반복 요소, 반복 수
rep(반복요소, 반복횟수)
x <- rep(1,5)
s <- rep(c(1:3,c(4,6)),3) # 1 2 3 4 6 1 2 3 4 6 1 2 3 4 6
t <- rep(c(1:3,c("a","b")),3) # "1" "2" "3" "a" "b" * 3
```

#### 6. 데이터 프레임

복수의 데이터 타입을 갖을 수 있는 데이터 형식

```R
a <- 1:9
b <- rep(c("a","b","c"), 3)
c <- rep(c(T,F),5)
X <- data.frame(Num=a,Char=b,Bool=c[-10])
X$Num # 1 2 3 4 5 6 7 8 9 오브젝트이름$열이름으로 참조 가능
X[,1] # 1 2 3 4 5 6 7 8 9
```

### 연산처리

```R
a <- c(10 %/% 3, 10 %% 3) # 3 1

m <- matrix(c(2,1,1,4,6,3,8,8,9), nrow=3, byrow=T)

# 전치 행렬의 생성
m.t <- t(m)

# 전치행렬과 원 행렬의 곱(행렬의 곱셈)
m.s <- m.t %*% m

# 역행렬의 계산
m.inv <- solve(m.s)

# 결과를 소수점 이하 4자리에서 반올림 하여 표시
round(m.i,digits=4)

# 사칙연산을 그대로 사용하면 같은 열과행의 요소끼리의 연산이 된다.
m10 <- m * 10
m10 - m
```

### 반복문

```R
# for
cnt <- 0
for(i in 1:10){
  cnt <- cnt + i
}
cnt # 55

# while
while(i<11){
  cnt <- cnt + i
  i <- i + 1
}
cnt # 55
```

### 조건분기문

```R
# if
if(논리식){
  논리식이 참일 경우에의 처리
} else {
  논리식이 거짓일 경우에의 처리
}

# 벡터오브젝트에 관한 조건분기

m <- -5:10
m # -5 -4 -3 -2 ... 7 8 9 10
m.p <- m[m>=0] # 0 1 2 3 ... 10
m[m > -3 & m < 4] # -2 -1 0 1 2 3
```

### 벡터에 대한 함수
```R
sum()
mean()
var() # 不偏分散
sd()
max()
min()

m <- matrix(1:10,ncol=2)
sum(m[,1]) # 15
```

### sapply

일반 언어의 map과 같은 역할.
벡터의 원소를 훑고 지나가면서 lambda함수에 나타난 대로 각각의 요소를 변화시킴.

```R
x <- c(9.66,12.06,2.24,9.53,11.95,11.70,4.40,1.97,13.69,13.61)
n <- length(x)
u <- 1/n * sum(x) # 母平均
x_var <- (1/(n-1)) * ((sum(sapply(x, function(x){x^2}))) - (sum(x))^2/n) # 母分散

u # 9.081
mean(x) # 9.081
x_var # 20.61485
var(x) # 20.61485
```

### Vectorize

vector를 필터링할때 사용 가능.
아래의 func의 조건에 따라서 원소들을 솎아주고 그것으로 구성된 새로운 벡터를 생성.

```R

# assignment2

x <- runif(9999,0,1)
y <- runif(9999,0,1)
x_2 <- sapply(x, function(x){x^2})
y_2 <- sapply(y, function(y){y^2})
z <- 0
func <- function(x){ x < 1 }
k <- x_2 + y_2
z <- length((x_2+y_2)[Vectorize(func)(k)])
pi <- z * 4 / 9999
pi # 3.140714

```
